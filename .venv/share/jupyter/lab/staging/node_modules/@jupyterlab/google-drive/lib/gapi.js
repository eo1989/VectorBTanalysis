"use strict";
// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const coreutils_1 = require("@lumino/coreutils");
const services_1 = require("@jupyterlab/services");
const drive_1 = require("./drive");
/**
 * Scope for the permissions needed for this extension.
 */
const DRIVE_SCOPE = 'https://www.googleapis.com/auth/drive';
const DISCOVERY_DOCS = [
    'https://www.googleapis.com/discovery/v1/apis/drive/v3/rest'
];
/**
 * Aliases for common API errors.
 */
const INVALID_CREDENTIALS_ERROR = 401;
const FORBIDDEN_ERROR = 403;
const BACKEND_ERROR = 500;
const RATE_LIMIT_REASON = 'userRateLimitExceeded';
/**
 * A promise delegate that is resolved when the google client
 * libraries are loaded onto the page.
 */
exports.gapiLoaded = new coreutils_1.PromiseDelegate();
/**
 * A promise delegate that is resolved when the gapi client
 * libraries are initialized.
 */
exports.gapiInitialized = new coreutils_1.PromiseDelegate();
/**
 * A promise delegate that is resolved when the user authorizes
 * the app to access their Drive account.
 *
 * #### Notes
 * This promise will be reassigned if the user logs out.
 */
exports.gapiAuthorized = new coreutils_1.PromiseDelegate();
/**
 * Load the gapi scripts onto the page.
 *
 * @returns a promise that resolves when the gapi scripts are loaded.
 */
function loadGapi() {
    return new Promise((resolve, reject) => {
        // Get the gapi script from Google.
        const gapiScript = document.createElement('script');
        gapiScript.src = 'https://apis.google.com/js/api.js';
        gapiScript.type = 'text/javascript';
        gapiScript.async = true;
        // Load overall API scripts onto the page.
        gapiScript.onload = () => {
            // Load the specific client libraries we need.
            const libs = 'client:auth2';
            gapi.load(libs, () => {
                exports.gapiLoaded.resolve(void 0);
                resolve(void 0);
            });
        };
        gapiScript.onerror = () => {
            console.error('Unable to load Google APIs');
            exports.gapiLoaded.reject(void 0);
            reject(void 0);
        };
        document.head.appendChild(gapiScript);
    });
}
exports.loadGapi = loadGapi;
/**
 * Initialize the gapi client libraries.
 *
 * @param clientId: The client ID for the project from the
 *   Google Developer Console. If not given, defaults to
 *   a testing project client ID. However, if you are deploying
 *   your own Jupyter server, or are making heavy use of the
 *   API, it is probably a good idea to set up your own client ID.
 *
 * @returns a promise that resolves when the client libraries are loaded.
 *   The return value of the promise is a boolean indicating whether
 *   the user was automatically signed in by the initialization.
 */
function initializeGapi(clientId) {
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        yield exports.gapiLoaded.promise;
        gapi.client
            .init({
            discoveryDocs: DISCOVERY_DOCS,
            clientId: clientId,
            scope: DRIVE_SCOPE
        })
            .then(() => {
            // Check if the user is logged in and we are
            // authomatically authorized.
            const googleAuth = gapi.auth2.getAuthInstance();
            if (googleAuth.isSignedIn.get()) {
                // Resolve the relevant promises.
                exports.gapiAuthorized.resolve(void 0);
                exports.gapiInitialized.resolve(void 0);
                resolve(true);
            }
            else {
                exports.gapiInitialized.resolve(void 0);
                resolve(false);
            }
        }, (err) => {
            exports.gapiInitialized.reject(err);
            // A useful error message is in err.details.
            reject(err.details);
        });
    }));
}
exports.initializeGapi = initializeGapi;
/**
 * Constants used when attempting exponential backoff.
 */
const MAX_API_REQUESTS = 7;
const BACKOFF_FACTOR = 2.0;
const INITIAL_DELAY = 250; // 250 ms.
/**
 * Wrapper function for making API requests to Google Drive.
 *
 * @param createRequest: a function that creates a request object for
 *   the Google Drive APIs. This is typically created by the Javascript
 *   client library. We use a request factory to create additional requests
 *   should we need to try exponential backoff.
 *
 * @param successCode: the code to check against for success of the request, defaults
 *   to 200.
 *
 * @param attemptNumber: the number of times this request has been made
 *   (used when attempting exponential backoff).
 *
 * @returns a promse that resolves with the result of the request.
 */
function driveApiRequest(createRequest, successCode = 200, attemptNumber = 0) {
    if (attemptNumber === MAX_API_REQUESTS) {
        throw Error('Maximum number of API retries reached.');
    }
    return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
        yield exports.gapiAuthorized.promise;
        const request = createRequest();
        request.then(response => {
            if (response.status !== successCode) {
                // Handle an HTTP error.
                let result = response.result;
                reject(makeError(result.error.code, result.error.message));
            }
            else {
                // If the response is note JSON-able, then `response.result`
                // will be `false`, and the raw data will be in `response.body`.
                // This happens, e.g., in the case of downloading raw image
                // data. This fix is a bit of a hack, but seems to work.
                if (response.result !== false) {
                    resolve(response.result);
                }
                else {
                    resolve(response.body);
                }
            }
        }, (response) => __awaiter(this, void 0, void 0, function* () {
            // Some error happened.
            if (response.status === BACKEND_ERROR ||
                (response.status === FORBIDDEN_ERROR &&
                    response.result.error.errors[0].reason ===
                        RATE_LIMIT_REASON)) {
                // If we are being rate limited, or if there is a backend error,
                // attempt exponential backoff.
                console.warn(`gapi: ${response.status} error, exponential ` +
                    `backoff attempt number ${attemptNumber}...`);
                window.setTimeout(() => {
                    // Try again after a delay.
                    driveApiRequest(createRequest, successCode, attemptNumber + 1).then(result => {
                        resolve(result);
                    });
                }, INITIAL_DELAY * Math.pow(BACKOFF_FACTOR, attemptNumber));
            }
            else if (response.status === INVALID_CREDENTIALS_ERROR) {
                // If we have invalid credentials, try to refresh
                // the authorization, then retry the request.
                yield Private.refreshAuthToken();
                try {
                    const result = yield driveApiRequest(createRequest, successCode, attemptNumber + 1);
                    resolve(result);
                }
                catch (err) {
                    let result = response.result;
                    reject(makeError(result.error.code, result.error.message));
                }
            }
            else {
                let result = response.result;
                reject(makeError(result.error.code, result.error.message));
            }
        }));
    }));
}
exports.driveApiRequest = driveApiRequest;
/**
 * Ask the user for permission to use their Google Drive account.
 * First it tries to authorize without a popup, and if it fails, it
 * creates a popup. If the argument `allowPopup` is false, then it will
 * not try to authorize with a popup.
 *
 * @returns: a promise that resolves with a boolean for whether permission
 *   has been granted.
 */
function signIn() {
    return __awaiter(this, void 0, void 0, function* () {
        return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {
            yield exports.gapiInitialized.promise;
            const googleAuth = gapi.auth2.getAuthInstance();
            if (!googleAuth.isSignedIn.get()) {
                googleAuth.signIn({ prompt: 'select_account' }).then(() => {
                    // Resolve the exported promise.
                    exports.gapiAuthorized.resolve(void 0);
                    resolve(true);
                });
            }
            else {
                // Otherwise we are already signed in.
                exports.gapiAuthorized.resolve(void 0);
                resolve(true);
            }
        }));
    });
}
exports.signIn = signIn;
/**
 * Sign a user out of their Google account.
 *
 * @returns a promise resolved when sign-out is complete.
 */
function signOut() {
    return __awaiter(this, void 0, void 0, function* () {
        const googleAuth = gapi.auth2.getAuthInstance();
        // Invalidate the gapiAuthorized promise and set up a new one.
        exports.gapiAuthorized = new coreutils_1.PromiseDelegate();
        yield googleAuth.signOut();
        drive_1.clearCache();
    });
}
exports.signOut = signOut;
/**
 * Get the basic profile of the currently signed-in user.
 *
 * @returns a `gapi.auth2.BasicProfile instance.
 */
function getCurrentUserProfile() {
    const user = gapi.auth2.getAuthInstance().currentUser.get();
    return user.getBasicProfile();
}
exports.getCurrentUserProfile = getCurrentUserProfile;
/**
 * Wrap an API error in a hacked-together error object
 * masquerading as an `ServerConnection.ResponseError`.
 */
function makeError(code, message) {
    const response = new Response(message, { status: code, statusText: message });
    return new services_1.ServerConnection.ResponseError(response, message);
}
exports.makeError = makeError;
/**
 * A namespace for private functions and values.
 */
var Private;
(function (Private) {
    /**
     * Try to manually refresh the authorization if we run
     * into credential problems.
     */
    function refreshAuthToken() {
        return new Promise((resolve, reject) => {
            const googleAuth = gapi.auth2.getAuthInstance();
            const user = googleAuth.currentUser.get();
            user.reloadAuthResponse().then(authResponse => {
                resolve(void 0);
            }, err => {
                console.error('gapi: Error on refreshing authorization!');
                reject(err);
            });
        });
    }
    Private.refreshAuthToken = refreshAuthToken;
})(Private || (Private = {}));
