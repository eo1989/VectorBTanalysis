"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const notebook_1 = require("@jupyterlab/notebook");
const apputils_1 = require("@jupyterlab/apputils");
const settingregistry_1 = require("@jupyterlab/settingregistry");
const mainmenu_1 = require("@jupyterlab/mainmenu");
const fileeditor_1 = require("@jupyterlab/fileeditor");
const client_1 = __importDefault(require("./client"));
const formatter_1 = require("./formatter");
const disposable_1 = require("@lumino/disposable");
const constants_1 = require("./constants");
const ui_components_1 = require("@jupyterlab/ui-components");
class JupyterLabCodeFormatter {
    constructor(app, tracker, palette, settingRegistry, menu, editorTracker) {
        this.app = app;
        this.tracker = tracker;
        this.editorTracker = editorTracker;
        this.palette = palette;
        this.settingRegistry = settingRegistry;
        this.menu = menu;
        this.client = new client_1.default();
        this.notebookCodeFormatter = new formatter_1.JupyterlabNotebookCodeFormatter(this.client, this.tracker);
        this.fileEditorCodeFormatter = new formatter_1.JupyterlabFileEditorCodeFormatter(this.client, this.editorTracker);
        this.checkVersion().then(versionMatches => {
            if (versionMatches) {
                this.setupSettings();
                this.setupAllCommands();
                this.setupContextMenu();
                this.setupWidgetExtension();
            }
        });
    }
    createNew(nb, context) {
        const self = this;
        const button = new apputils_1.ToolbarButton({
            tooltip: 'Format notebook',
            icon: new ui_components_1.LabIcon({
                name: constants_1.Constants.FORMAT_ALL_COMMAND,
                svgstr: constants_1.Constants.ICON_FORMAT_ALL_SVG
            }),
            onClick: () => __awaiter(this, void 0, void 0, function* () {
                yield self.notebookCodeFormatter.formatAllCodeCells(this.config, undefined, nb.content);
            })
        });
        nb.toolbar.insertAfter('cellType', this.app.commands.label(constants_1.Constants.FORMAT_ALL_COMMAND), button);
        return new disposable_1.DisposableDelegate(() => {
            button.dispose();
        });
    }
    setupWidgetExtension() {
        this.app.docRegistry.addWidgetExtension('Notebook', this);
    }
    setupContextMenu() {
        this.app.contextMenu.addItem({
            command: constants_1.Constants.FORMAT_COMMAND,
            selector: '.jp-Notebook'
        });
    }
    setupAllCommands() {
        this.client.getAvailableFormatters().then(data => {
            const formatters = JSON.parse(data).formatters;
            const menuGroup = [];
            Object.keys(formatters).forEach(formatter => {
                if (formatters[formatter].enabled) {
                    const command = `${constants_1.Constants.SHORT_PLUGIN_NAME}:${formatter}`;
                    this.setupCommand(formatter, formatters[formatter].label, command);
                    menuGroup.push({ command });
                }
            });
            this.menu.editMenu.addGroup(menuGroup);
        });
        this.app.commands.addCommand(constants_1.Constants.FORMAT_COMMAND, {
            execute: () => __awaiter(this, void 0, void 0, function* () {
                yield this.notebookCodeFormatter.formatSelectedCodeCells(this.config);
            }),
            // TODO: Add back isVisible
            label: 'Format cell'
        });
        this.app.commands.addCommand(constants_1.Constants.FORMAT_ALL_COMMAND, {
            execute: () => __awaiter(this, void 0, void 0, function* () {
                yield this.notebookCodeFormatter.formatAllCodeCells(this.config);
            }),
            iconClass: constants_1.Constants.ICON_FORMAT_ALL,
            iconLabel: 'Format notebook'
            // TODO: Add back isVisible
        });
    }
    setupSettings() {
        const self = this;
        Promise.all([this.settingRegistry.load(constants_1.Constants.SETTINGS_SECTION)])
            .then(([settings]) => {
            function onSettingsUpdated(jsettings) {
                self.config = jsettings.composite;
            }
            settings.changed.connect(onSettingsUpdated);
            onSettingsUpdated(settings);
        })
            .catch((error) => {
            void apputils_1.showErrorMessage('Jupyterlab Code Formatter Error', error);
        });
    }
    setupCommand(name, label, command) {
        this.app.commands.addCommand(command, {
            execute: () => __awaiter(this, void 0, void 0, function* () {
                for (let formatter of [
                    this.notebookCodeFormatter,
                    this.fileEditorCodeFormatter
                ]) {
                    if (formatter.applicable(name, this.app.shell.currentWidget)) {
                        yield formatter.formatAction(this.config, name);
                    }
                }
            }),
            isVisible: () => {
                for (let formatter of [
                    this.notebookCodeFormatter,
                    this.fileEditorCodeFormatter
                ]) {
                    if (formatter.applicable(name, this.app.shell.currentWidget)) {
                        return true;
                    }
                }
                return false;
            },
            label
        });
        this.palette.addItem({ command, category: constants_1.Constants.COMMAND_SECTION_NAME });
    }
    checkVersion() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.client
                .getVersion()
                .then(data => {
                let serverPluginVersion = JSON.parse(data).version;
                let versionMatches = serverPluginVersion === constants_1.Constants.PLUGIN_VERSION;
                if (!versionMatches) {
                    void apputils_1.showErrorMessage('Jupyterlab Code Formatter Version Mismatch', `Lab plugin version: ${constants_1.Constants.PLUGIN_VERSION}. ` +
                        `Server plugin version: ${serverPluginVersion}.`);
                }
                return versionMatches;
            })
                .catch(error => {
                void apputils_1.showErrorMessage('Jupyterlab Code Formatter Error', 'Unable to find server plugin version, consider upgrading.');
                return false;
            });
        });
    }
}
/**
 * Initialization data for the jupyterlab_code_formatter extension.
 */
const extension = {
    activate: (app, palette, tracker, settingRegistry, menu, editorTracker) => {
        new JupyterLabCodeFormatter(app, tracker, palette, settingRegistry, menu, editorTracker);
    },
    autoStart: true,
    id: constants_1.Constants.SHORT_PLUGIN_NAME,
    requires: [
        apputils_1.ICommandPalette,
        notebook_1.INotebookTracker,
        settingregistry_1.ISettingRegistry,
        mainmenu_1.IMainMenu,
        fileeditor_1.IEditorTracker
    ]
};
exports.default = extension;
