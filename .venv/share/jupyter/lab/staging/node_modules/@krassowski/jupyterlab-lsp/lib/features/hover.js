import { getModifierState, uris_equal } from '../utils';
import { is_equal } from '../positioning';
import { Debouncer } from '@lumino/polling';
import { CodeMirrorIntegration } from '../editor_integration/codemirror';
import { FeatureSettings } from '../feature';
import { EditorTooltipManager } from '../components/free_tooltip';
import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
import { ILSPAdapterManager, ILSPFeatureManager, PLUGIN_ID } from '../tokens';
import { ISettingRegistry } from '@jupyterlab/settingregistry';
import { LabIcon } from '@jupyterlab/ui-components';
import hoverSvg from '../../style/icons/hover.svg';
export const hoverIcon = new LabIcon({
    name: 'lsp:hover',
    svgstr: hoverSvg
});
export class HoverCM extends CodeMirrorIntegration {
    constructor() {
        super(...arguments);
        this.on_hover = async () => {
            return await this.connection.getHoverTooltip(this.virtual_position, this.virtual_document.document_info, false);
        };
        this.handleHover = (response, documentUri) => {
            if (!uris_equal(documentUri, this.virtual_document.document_info.uri)) {
                return;
            }
            this.hide_hover();
            this.last_hover_character = null;
            this.last_hover_response = null;
            if (!this.hover_character ||
                !response ||
                !response.contents ||
                (Array.isArray(response.contents) && response.contents.length === 0)) {
                return;
            }
            this.hover_marker = this.highlight_range(this.editor_range_for_hover(response.range), 'cm-lsp-hover-available');
            if (!this.show_next_tooltip) {
                this.last_hover_response = response;
                this.last_hover_character = this.hover_character;
                return;
            }
            const markup = HoverCM.get_markup_for_hover(response);
            let root_position = this.hover_character;
            let cm_editor = this.get_cm_editor(root_position);
            let editor_position = this.virtual_editor.root_position_to_editor(root_position);
            this.lab_integration.tooltip.create({
                markup,
                position: editor_position,
                ce_editor: this.virtual_editor.find_ce_editor(cm_editor)
            });
        };
        this.handleMouseOver = (event) => {
            // proceed when no hover modifier or hover modifier pressed
            this.show_next_tooltip =
                !this.modifierKey || getModifierState(event, this.modifierKey);
            try {
                return this._handleMouseOver(event);
            }
            catch (e) {
                if (!(e.message === 'Cell not found in cell_line_map' ||
                    e.message === "Cannot read property 'string' of undefined")) {
                    console.warn(e);
                }
            }
        };
        this.remove_range_highlight = () => {
            if (this.hover_marker) {
                this.hover_marker.clear();
                this.hover_marker = null;
            }
            this.last_hover_character = null;
        };
    }
    get modifierKey() {
        return this.settings.composite.modifierKey;
    }
    register() {
        this.wrapper_handlers.set('mousemove', this.handleMouseOver);
        this.wrapper_handlers.set('mouseleave', 
        // TODO: remove_tooltip() but allow the mouse to leave if it enters the tooltip
        //  (a bit tricky: normally we would just place the tooltip within, but it was designed to be attached to body)
        this.remove_range_highlight);
        // show hover after pressing the modifier key
        this.wrapper_handlers.set('keydown', (event) => {
            if ((!this.modifierKey || getModifierState(event, this.modifierKey)) &&
                this.hover_character === this.last_hover_character) {
                this.show_next_tooltip = true;
                this.handleHover(this.last_hover_response, this.virtual_document.document_info.uri);
            }
        });
        // TODO: make the debounce rate configurable
        this.debounced_get_hover = new Debouncer(this.on_hover, 50);
        super.register();
    }
    static get_markup_for_hover(response) {
        let contents = response.contents;
        // this causes the webpack to fail "Module not found: Error: Can't resolve 'net'" for some reason
        // if (lsProtocol.MarkedString.is(contents))
        ///  contents = [contents];
        if (typeof contents === 'string') {
            contents = [contents];
        }
        if (!Array.isArray(contents)) {
            return contents;
        }
        // now we have MarkedString
        let content = contents[0];
        if (typeof content === 'string') {
            // coerce to MarkedString  object
            return {
                kind: 'plaintext',
                value: content
            };
        }
        else {
            return {
                kind: 'markdown',
                value: '```' + content.language + '\n' + content.value + '```'
            };
        }
    }
    is_token_empty(token) {
        return token.string.length === 0;
        // TODO  || token.type.length === 0? (sometimes the underline is shown on meaningless tokens)
    }
    is_event_inside_visible(event) {
        let target = event.target;
        return target.closest('.CodeMirror-sizer') != null;
    }
    async _handleMouseOver(event) {
        // currently the events are coming from notebook panel; ideally these would be connected to individual cells,
        // (only cells with code) instead, but this is more complex to implement right. In any case filtering
        // is needed to determine in hovered character belongs to this virtual document
        let root_position = this.position_from_mouse(event);
        // happens because mousemove is attached to panel, not individual code cells,
        // and because some regions of the editor (between lines) have no characters
        if (root_position == null) {
            // this.remove_range_highlight();
            this.hover_character = null;
            return;
        }
        let token = this.virtual_editor.getTokenAt(root_position);
        let document = this.virtual_editor.document_at_root_position(root_position);
        let virtual_position = this.virtual_editor.root_position_to_virtual_position(root_position);
        if (this.is_token_empty(token) ||
            document !== this.virtual_document ||
            !this.is_event_inside_visible(event)) {
            // this.remove_range_highlight();
            this.hover_character = null;
            return;
        }
        if (!is_equal(root_position, this.hover_character)) {
            this.hover_character = root_position;
            this.virtual_position = virtual_position;
            const hover = await this.debounced_get_hover.invoke();
            this.handleHover(hover, this.virtual_document.document_info.uri);
        }
    }
    editor_range_for_hover(range) {
        let character = this.hover_character;
        // NOTE: foreign document ranges are checked before the request is sent,
        // no need to to this again here.
        if (range) {
            let ce_editor = this.virtual_editor.get_editor_at_root_position(character);
            let cm_editor = this.virtual_editor.ce_editor_to_cm_editor.get(ce_editor);
            return this.range_to_editor_range(range, cm_editor);
        }
        else {
            // construct range manually using the token information
            let ce_editor = this.virtual_document.root.get_editor_at_source_line(character);
            let cm_editor = this.virtual_editor.ce_editor_to_cm_editor.get(ce_editor);
            let token = this.virtual_editor.getTokenAt(character);
            let start_in_root = {
                line: character.line,
                ch: token.start
            };
            let end_in_root = {
                line: character.line,
                ch: token.end
            };
            return {
                start: this.virtual_editor.root_position_to_editor(start_in_root),
                end: this.virtual_editor.root_position_to_editor(end_in_root),
                editor: cm_editor
            };
        }
    }
    hide_hover() {
        this.lab_integration.tooltip.remove();
        this.remove_range_highlight();
    }
    remove() {
        this.remove_range_highlight();
        this.debounced_get_hover.dispose();
        super.remove();
        // just to be sure
        this.debounced_get_hover = null;
        this.remove_range_highlight = null;
        this.handleHover = null;
        this.on_hover = null;
    }
}
class HoverLabIntegration {
    constructor(app, settings, renderMimeRegistry, adapterManager) {
        this.tooltip = new EditorTooltipManager(renderMimeRegistry, adapterManager);
    }
}
const FEATURE_ID = PLUGIN_ID + ':hover';
export const HOVER_PLUGIN = {
    id: FEATURE_ID,
    requires: [
        ILSPFeatureManager,
        ISettingRegistry,
        IRenderMimeRegistry,
        ILSPAdapterManager
    ],
    autoStart: true,
    activate: (app, featureManager, settingRegistry, renderMimeRegistry, adapterManager) => {
        const settings = new FeatureSettings(settingRegistry, FEATURE_ID);
        const labIntegration = new HoverLabIntegration(app, settings, renderMimeRegistry, adapterManager);
        featureManager.register({
            feature: {
                editorIntegrationFactory: new Map([['CodeMirrorEditor', HoverCM]]),
                id: FEATURE_ID,
                name: 'LSP Hover tooltip',
                labIntegration: labIntegration,
                settings: settings
            }
        });
    }
};
//# sourceMappingURL=hover.js.map