// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
// Based on the @jupyterlab/codemirror-extension statusbar
import React from 'react';
import { VDomModel, VDomRenderer } from '@jupyterlab/apputils';
import '../../../../style/statusbar.css';
import { GroupItem, interactiveItem, showPopup, TextItem } from '@jupyterlab/statusbar';
import { refreshIcon, runningIcon, stopIcon } from '@jupyterlab/ui-components';
import { collect_documents } from '../../../virtual/document';
function ServerStatus(props) {
    let list = props.server.spec.languages.map((language, i) => (React.createElement("li", { key: i }, language)));
    return (React.createElement("div", { className: 'lsp-server-status' },
        React.createElement("h5", null, props.server.spec.display_name),
        React.createElement("ul", null, list)));
}
class CollapsibleList extends React.Component {
    constructor(props) {
        super(props);
        this.handleClick = () => {
            this.setState(state => ({
                isCollapsed: !state.isCollapsed
            }));
        };
        this.state = { isCollapsed: props.startCollapsed || false };
    }
    render() {
        return (React.createElement("div", { className: 'lsp-collapsible-list ' +
                (this.state.isCollapsed ? 'lsp-collapsed' : '') },
            React.createElement("h4", { onClick: this.handleClick },
                React.createElement("span", { className: 'lsp-caret' }),
                this.props.title,
                " (",
                this.props.list.length,
                ")"),
            React.createElement("div", null, this.props.list)));
    }
}
class LSPPopup extends VDomRenderer {
    constructor(model) {
        super(model);
        this.addClass('lsp-popover');
    }
    render() {
        var _a;
        if (!((_a = this.model) === null || _a === void 0 ? void 0 : _a.connection_manager)) {
            return null;
        }
        const servers_available = this.model.servers_available_not_in_use.map((session, i) => React.createElement(ServerStatus, { key: i, server: session }));
        let running_servers = new Array();
        let key = -1;
        for (let [session, documents_by_language] of this.model.documents_by_server.entries()) {
            key += 1;
            let documents_html = new Array();
            for (let [language, documents] of documents_by_language) {
                // TODO user readable document ids: filename, [cell id]
                // TODO: stop button
                // TODO: add a config buttons next to the language header
                let list = documents.map((document, i) => {
                    let connection = this.model.connection_manager.connections.get(document.id_path);
                    let status = '';
                    if (connection === null || connection === void 0 ? void 0 : connection.isInitialized) {
                        status = 'initialized';
                    }
                    else if (connection === null || connection === void 0 ? void 0 : connection.isConnected) {
                        status = 'connected';
                    }
                    else {
                        status = 'not connected';
                    }
                    return (React.createElement("li", { key: i },
                        document.id_path,
                        React.createElement("span", { className: 'lsp-document-status' },
                            status,
                            React.createElement("span", { className: 'lsp-document-status-icon ' +
                                    (status === 'initialized'
                                        ? 'jp-FilledCircleIcon'
                                        : 'jp-CircleIcon') }))));
                });
                documents_html.push(React.createElement("div", { key: key, className: 'lsp-documents-by-language' },
                    React.createElement("h5", null,
                        language,
                        ' ',
                        React.createElement("span", { className: 'lsp-language-server-name' },
                            "(",
                            session.spec.display_name,
                            ")")),
                    React.createElement("ul", null, list)));
            }
            running_servers.push(React.createElement("div", { key: key }, documents_html));
        }
        const missing_languages = this.model.missing_languages.map((language, i) => (React.createElement("div", { key: i, className: 'lsp-missing-server' }, language)));
        return (React.createElement("div", { className: 'lsp-popover-content' },
            React.createElement("div", { className: 'lsp-servers-menu' },
                React.createElement("h3", { className: 'lsp-servers-title' }, "LSP servers"),
                React.createElement("div", { className: 'lsp-servers-lists' },
                    servers_available.length ? (React.createElement(CollapsibleList, { key: 'available', title: 'Available', list: servers_available, startCollapsed: true })) : (''),
                    running_servers.length ? (React.createElement(CollapsibleList, { key: 'running', title: 'Running', list: running_servers })) : (''),
                    missing_languages.length ? (React.createElement(CollapsibleList, { key: 'missing', title: 'Missing', list: missing_languages })) : (''))),
            React.createElement("div", { className: 'lsp-popover-status' },
                "Documentation:",
                ' ',
                React.createElement("a", { href: 'https://jupyterlab-lsp.readthedocs.io/en/latest/Language%20Servers.html', target: "_blank", rel: "noreferrer" }, "Language Servers"))));
    }
}
/**
 * StatusBar item.
 */
export class LSPStatus extends VDomRenderer {
    /**
     * Construct a new VDomRenderer for the status item.
     */
    constructor() {
        super(new LSPStatus.Model());
        this._popup = null;
        this.handleClick = () => {
            if (this._popup) {
                this._popup.dispose();
            }
            this._popup = showPopup({
                body: new LSPPopup(this.model),
                anchor: this,
                align: 'left'
            });
        };
        this.addClass(interactiveItem);
        this.addClass('lsp-statusbar-item');
        this.title.caption = 'LSP status';
    }
    /**
     * Render the status item.
     */
    render() {
        if (!this.model) {
            return null;
        }
        return (React.createElement(GroupItem, { spacing: 4, title: this.model.long_message, onClick: this.handleClick },
            React.createElement(this.model.status_icon.react, { top: '2px', kind: 'statusBar', title: 'LSP Code Intelligence' }),
            React.createElement(TextItem, { source: this.model.short_message }),
            React.createElement(TextItem, { source: this.model.feature_message })));
    }
}
function collect_languages(virtual_document) {
    let documents = collect_documents(virtual_document);
    return new Set([...documents].map(document => document.language.toLocaleLowerCase()));
}
const iconByStatus = {
    waiting: refreshIcon,
    initialized: runningIcon,
    initializing: refreshIcon,
    connecting: refreshIcon
};
const shortMessageByStatus = {
    waiting: 'Waiting...',
    initialized: 'Fully initialized',
    initializing: 'Partially initialized',
    connecting: 'Connecting...'
};
(function (LSPStatus) {
    /**
     * A VDomModel for the LSP of current file editor/notebook.
     */
    class Model extends VDomModel {
        constructor() {
            super(...arguments);
            this.server_extension_status = null;
            this._onChange = () => {
                this.stateChanged.emit(void 0);
            };
            this._adapter = null;
        }
        get available_servers() {
            return Array.from(this.language_server_manager.sessions.values());
        }
        get supported_languages() {
            const languages = new Set();
            for (let server of this.available_servers) {
                for (let language of server.spec.languages) {
                    languages.add(language.toLocaleLowerCase());
                }
            }
            return languages;
        }
        is_server_running(server) {
            for (let language of server.spec.languages) {
                if (this.detected_languages.has(language.toLocaleLowerCase())) {
                    return true;
                }
            }
            return false;
        }
        get documents_by_server() {
            var _a;
            let data = new Map();
            if (!((_a = this.adapter) === null || _a === void 0 ? void 0 : _a.virtual_editor)) {
                return data;
            }
            let main_document = this.adapter.virtual_editor.virtual_document;
            let documents = collect_documents(main_document);
            for (let document of documents.values()) {
                let language = document.language.toLocaleLowerCase();
                let servers = this.available_servers.filter(server => server.spec.languages.indexOf(language) !== -1);
                if (servers.length > 1) {
                    console.warn('More than one server per language for' + language);
                }
                if (servers.length === 0) {
                    continue;
                }
                let server = servers[0];
                if (!data.has(server)) {
                    data.set(server, new Map());
                }
                let documents_map = data.get(server);
                if (!documents_map.has(language)) {
                    documents_map.set(language, new Array());
                }
                let documents = documents_map.get(language);
                documents.push(document);
            }
            return data;
        }
        get servers_available_not_in_use() {
            return this.available_servers.filter(server => !this.is_server_running(server));
        }
        get detected_languages() {
            var _a;
            if (!((_a = this.adapter) === null || _a === void 0 ? void 0 : _a.virtual_editor)) {
                return new Set();
            }
            let document = this.adapter.virtual_editor.virtual_document;
            return collect_languages(document);
        }
        get missing_languages() {
            // TODO: false negative for r vs R?
            return [...this.detected_languages].filter(language => !this.supported_languages.has(language.toLocaleLowerCase()));
        }
        get status() {
            const detected_documents = this._connection_manager.documents;
            let connected_documents = new Set();
            let initialized_documents = new Set();
            detected_documents.forEach((document, id_path) => {
                let connection = this._connection_manager.connections.get(id_path);
                if (!connection) {
                    return;
                }
                if (connection.isConnected) {
                    connected_documents.add(document);
                }
                if (connection.isInitialized) {
                    initialized_documents.add(document);
                }
            });
            // there may be more open connections than documents if a document was recently closed
            // and the grace period has not passed yet
            let open_connections = new Array();
            this._connection_manager.connections.forEach((connection, path) => {
                if (connection.isConnected) {
                    open_connections.push(connection);
                }
            });
            let status;
            if (detected_documents.size === 0) {
                status = 'waiting';
                // TODO: instead of detected documents, I should use "detected_documents_with_LSP_servers_available"
            }
            else if (initialized_documents.size === detected_documents.size) {
                status = 'initialized';
            }
            else if (connected_documents.size === detected_documents.size) {
                status = 'initializing';
            }
            else {
                status = 'connecting';
            }
            return {
                open_connections,
                connected_documents,
                initialized_documents,
                detected_documents: new Set([...detected_documents.values()]),
                status
            };
        }
        get status_icon() {
            if (!this.adapter) {
                return stopIcon;
            }
            return iconByStatus[this.status.status];
        }
        get short_message() {
            if (!this.adapter) {
                return 'not initialized';
            }
            return shortMessageByStatus[this.status.status];
        }
        get feature_message() {
            var _a, _b;
            return ((_b = (_a = this.adapter) === null || _a === void 0 ? void 0 : _a.status_message) === null || _b === void 0 ? void 0 : _b.message) || '';
        }
        get long_message() {
            if (!this.adapter) {
                return 'not initialized';
            }
            let status = this.status;
            let msg = '';
            const plural = status.detected_documents.size > 1 ? 's' : '';
            if (status.status === 'waiting') {
                msg = 'Waiting for documents initialization...';
            }
            else if (status.status === 'initialized') {
                msg = `Fully connected & initialized (${status.detected_documents.size} virtual document${plural})`;
            }
            else if (status.status === 'initializing') {
                const uninitialized = new Set(status.detected_documents);
                for (let initialized of status.initialized_documents.values()) {
                    uninitialized.delete(initialized);
                }
                // servers for n documents did not respond ot the initialization request
                msg = `Fully connected, but ${uninitialized.size}/${status.detected_documents.size} virtual document${plural} stuck uninitialized: ${[...uninitialized]
                    .map(document => document.id_path)
                    .join(', ')}`;
            }
            else {
                const unconnected = new Set(status.detected_documents);
                for (let connected of status.connected_documents.values()) {
                    unconnected.delete(connected);
                }
                msg = `${status.connected_documents.size}/${status.detected_documents.size} virtual document${plural} connected (${status.open_connections.length} connections; waiting for: ${[...unconnected]
                    .map(document => document.id_path)
                    .join(', ')})`;
            }
            return msg;
        }
        get adapter() {
            return this._adapter;
        }
        set adapter(adapter) {
            if (this._adapter != null) {
                this._adapter.status_message.changed.connect(this._onChange);
            }
            if (adapter != null) {
                adapter.status_message.changed.connect(this._onChange);
            }
            this._adapter = adapter;
        }
        get connection_manager() {
            return this._connection_manager;
        }
        set connection_manager(connection_manager) {
            if (this._connection_manager != null) {
                this._connection_manager.connected.disconnect(this._onChange);
                this._connection_manager.initialized.connect(this._onChange);
                this._connection_manager.disconnected.disconnect(this._onChange);
                this._connection_manager.closed.disconnect(this._onChange);
                this._connection_manager.documents_changed.disconnect(this._onChange);
            }
            if (connection_manager != null) {
                connection_manager.connected.connect(this._onChange);
                connection_manager.initialized.connect(this._onChange);
                connection_manager.disconnected.connect(this._onChange);
                connection_manager.closed.connect(this._onChange);
                connection_manager.documents_changed.connect(this._onChange);
            }
            this._connection_manager = connection_manager;
        }
    }
    LSPStatus.Model = Model;
})(LSPStatus || (LSPStatus = {}));
//# sourceMappingURL=statusbar.js.map