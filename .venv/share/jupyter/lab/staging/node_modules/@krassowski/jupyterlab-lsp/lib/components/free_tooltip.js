// Copyright (c) Jupyter Development Team.
// Distributed under the terms of the Modified BSD License.
// (Parts of the FreeTooltip code are copy-paste from Tooltip, ideally this would be PRed be merged)
import { Tooltip } from '@jupyterlab/tooltip';
import { HoverBox } from '@jupyterlab/apputils';
import { PositionConverter } from '../converter';
import { Widget } from '@lumino/widgets';
const MIN_HEIGHT = 20;
const MAX_HEIGHT = 250;
/**
 * Tooltip which can be placed  at any character, not only at the current position (derived from getCursorPosition)
 */
// eslint-disable-next-line @typescript-eslint/ban-ts-ignore
// @ts-ignore
export class FreeTooltip extends Tooltip {
    constructor(options) {
        super(options);
        this.position = options.position;
        this.movetoLineEnd = options.moveToLineEnd;
    }
    // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
    // @ts-ignore
    _setGeometry() {
        // Find the start of the current token for hover box placement.
        // eslint-disable-next-line @typescript-eslint/ban-ts-ignore
        // @ts-ignore
        const editor = this._editor;
        const cursor = this.position == null ? editor.getCursorPosition() : this.position;
        const end = editor.getOffsetAt(cursor);
        const line = editor.getLine(cursor.line);
        if (!line) {
            return;
        }
        let position;
        if (this.movetoLineEnd) {
            const tokens = line.substring(0, end).split(/\W+/);
            const last = tokens[tokens.length - 1];
            const start = last ? end - last.length : end;
            position = editor.getPositionAt(start);
        }
        else {
            position = cursor;
        }
        if (!position) {
            return;
        }
        const anchor = editor.getCoordinateForPosition(position);
        const style = window.getComputedStyle(this.node);
        const paddingLeft = parseInt(style.paddingLeft, 10) || 0;
        // Calculate the geometry of the tooltip.
        HoverBox.setGeometry({
            anchor,
            host: editor.host,
            maxHeight: MAX_HEIGHT,
            minHeight: MIN_HEIGHT,
            node: this.node,
            offset: { horizontal: -1 * paddingLeft },
            privilege: 'below',
            style: style
        });
    }
}
export class EditorTooltipManager {
    constructor(rendermime_registry, adapterManager) {
        this.rendermime_registry = rendermime_registry;
        this.adapterManager = adapterManager;
        this.currentTooltip = null;
    }
    create(options) {
        this.remove();
        let { markup, position } = options;
        let adapter = this.adapterManager.currentAdapter;
        let widget = adapter.widget;
        const bundle = markup.kind === 'plaintext'
            ? { 'text/plain': markup.value }
            : { 'text/markdown': markup.value };
        const tooltip = new FreeTooltip({
            anchor: widget.content,
            bundle: bundle,
            editor: options.ce_editor,
            rendermime: this.rendermime_registry,
            position: PositionConverter.cm_to_ce(position),
            moveToLineEnd: false
        });
        Widget.attach(tooltip, document.body);
        this.currentTooltip = tooltip;
        return tooltip;
    }
    remove() {
        if (this.currentTooltip !== null) {
            this.currentTooltip.dispose();
        }
    }
}
//# sourceMappingURL=free_tooltip.js.map