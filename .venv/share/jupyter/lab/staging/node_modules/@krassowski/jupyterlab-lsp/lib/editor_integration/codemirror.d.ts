import { IFeatureEditorIntegration, IEditorIntegrationOptions, IFeature, IFeatureSettings } from '../feature';
import { VirtualDocument } from '../virtual/document';
import { LSPConnection } from '../connection';
import * as CodeMirror from 'codemirror';
import { IEditorPosition, IRootPosition, IVirtualPosition } from '../positioning';
import * as lsProtocol from 'vscode-languageserver-protocol';
import { CodeEditor } from '@jupyterlab/codeeditor';
import { CodeMirrorHandler, CodeMirrorVirtualEditor } from '../virtual/codemirror_editor';
import { StatusMessage, WidgetAdapter } from '../adapters/adapter';
import { IDocumentWidget } from '@jupyterlab/docregistry';
import { IEditorChange } from '../virtual/editor';
export interface IEditorRange {
    start: IEditorPosition;
    end: IEditorPosition;
    editor: CodeMirror.Editor;
}
export interface IEditOutcome {
    appliedChanges: number | null;
    modifiedCells: number;
    wasGranular: boolean;
    errors: string[];
}
/**
 * One feature of each type exists per VirtualDocument
 * (the initialization is performed by the adapter).
 */
export declare abstract class CodeMirrorIntegration implements IFeatureEditorIntegration<CodeMirrorVirtualEditor> {
    is_registered: boolean;
    feature: IFeature;
    protected readonly editor_handlers: Map<string, CodeMirrorHandler>;
    protected readonly connection_handlers: Map<string, any>;
    protected readonly wrapper_handlers: Map<keyof HTMLElementEventMap, any>;
    protected wrapper: HTMLElement;
    protected virtual_editor: CodeMirrorVirtualEditor;
    protected virtual_document: VirtualDocument;
    protected connection: LSPConnection;
    protected status_message: StatusMessage;
    protected adapter: WidgetAdapter<IDocumentWidget>;
    get settings(): IFeatureSettings<any>;
    get lab_integration(): import("../feature").IFeatureLabIntegration;
    constructor(options: IEditorIntegrationOptions);
    register(): void;
    remove(): void;
    protected range_to_editor_range(range: lsProtocol.Range, cm_editor?: CodeMirror.Editor): IEditorRange;
    protected position_from_mouse(event: MouseEvent): IRootPosition;
    transform_virtual_position_to_root_position(start: IVirtualPosition): IRootPosition;
    protected get_cm_editor(position: IRootPosition): CodeMirror.Editor;
    protected get_language_at(position: IEditorPosition, editor: CodeMirror.Editor): any;
    protected extract_last_character(change: CodeMirror.EditorChange): string;
    protected highlight_range(range: IEditorRange, class_name: string): CodeMirror.TextMarker;
    /**
     * Does the edit cover the entire document?
     */
    protected is_whole_document_edit(edit: lsProtocol.TextEdit): boolean;
    protected apply_edit(workspaceEdit: lsProtocol.WorkspaceEdit): Promise<IEditOutcome>;
    protected replace_fragment(newText: string, editor: CodeEditor.IEditor, fragment_start: CodeMirror.Position, fragment_end: CodeMirror.Position, start: CodeMirror.Position, end: CodeMirror.Position, is_whole_document_edit?: boolean): number;
    afterChange(change: IEditorChange, root_position: IRootPosition): void;
    protected apply_single_edit(edit: lsProtocol.TextEdit): number;
}
export declare type CodeMirrorIntegrationConstructor = {
    new (options: IEditorIntegrationOptions): CodeMirrorIntegration;
};
