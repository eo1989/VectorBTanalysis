import { until_ready } from '../utils';
import { create_console } from '../virtual/console';
export class EditorAdapter {
    constructor(editor, virtual_document, features = new Array()) {
        this.editor = editor;
        this.virtual_document = virtual_document;
        this.isDisposed = false;
        this.editor.change.connect(this.saveChange, this);
        this.console = create_console('browser');
        this.features = new Map();
        for (let feature of features) {
            feature.register();
            if (!feature.is_registered) {
                this.console.warn('The feature ', feature, 'was not registered properly');
            }
            this.features.set(feature.feature.id, feature);
        }
    }
    async updateAfterChange() {
        try {
            await until_ready(() => this.last_change != null, 30, 22);
        }
        catch (err) {
            console.log('No change obtained from CodeMirror editor within the expected time of 0.66s');
            return;
        }
        let change = this.last_change;
        let root_position;
        try {
            root_position = this.editor.get_cursor_position();
        }
        catch (err) {
            console.log('LSP: Root position not found');
            return;
        }
        try {
            let document = this.editor.document_at_root_position(root_position);
            if (this.virtual_document !== document) {
                return true;
            }
            if (!change || !change.text.length || !change.text[0].length) {
                // deletion - ignore
                return true;
            }
            for (let feature of this.features.values()) {
                try {
                    feature.afterChange(change, root_position);
                }
                catch (err) {
                    console.warn('afterChange of feature', feature, 'failed with', err);
                }
            }
            return true;
        }
        catch (e) {
            this.console.log('updateAfterChange failure');
            this.console.error(e);
        }
        this.invalidateLastChange();
    }
    invalidateLastChange() {
        this.last_change = null;
    }
    saveChange(sender, change) {
        this.last_change = change;
    }
    dispose() {
        if (this.isDisposed) {
            return;
        }
        for (let feature of this.features.values()) {
            feature.remove();
        }
        this.features.clear();
        this.editor.change.disconnect(this.saveChange);
        // just to be sure
        this.editor = null;
        // actually disposed
        this.isDisposed = true;
    }
}
//# sourceMappingURL=editor_adapter.js.map