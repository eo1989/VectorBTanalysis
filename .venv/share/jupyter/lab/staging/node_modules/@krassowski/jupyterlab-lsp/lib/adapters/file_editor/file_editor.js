import { WidgetAdapter } from '../adapter';
import { PositionConverter } from '../../converter';
import { VirtualDocument } from '../../virtual/document';
export class FileEditorAdapter extends WidgetAdapter {
    constructor(extension, editor_widget) {
        super(extension, editor_widget);
        this.editor = editor_widget.content;
        this.init_virtual();
        this.connect_contentChanged_signal();
        console.log('LSP: file ready for connection:', this.path);
        // connect the document, but do not open it as the adapter will handle this
        // after registering all features
        this.connect_document(this.virtual_editor.virtual_document, false).catch(console.warn);
        this.editor.model.mimeTypeChanged.connect(this.reload_connection, this);
    }
    get document_path() {
        return this.widget.context.path;
    }
    get mime_type() {
        return this.editor.model.mimeType;
    }
    get language_file_extension() {
        let parts = this.document_path.split('.');
        return parts[parts.length - 1];
    }
    get ce_editor() {
        return this.editor.editor;
    }
    get activeEditor() {
        return this.editor.editor;
    }
    get_editor_index(ce_editor) {
        return 0;
    }
    get_editor_wrapper(ce_editor) {
        return this.wrapper_element;
    }
    get wrapper_element() {
        return this.widget.node;
    }
    get path() {
        return this.widget.context.path;
    }
    context_from_active_document() {
        let editor = this.widget.content.editor;
        let ce_cursor = editor.getCursorPosition();
        let root_position = PositionConverter.ce_to_cm(ce_cursor);
        return this === null || this === void 0 ? void 0 : this.get_context(root_position);
    }
    get_editor_index_at(position) {
        return 0;
    }
    get editors() {
        return [this.editor.editor];
    }
    create_virtual_document() {
        // TODO: for now the magics and extractors are not used in FileEditor,
        //  although it would make sense to pass extractors (e.g. for CSS in HTML,
        //  or SQL in Python files) in the future. However, these would need to be
        //  a different registry (as we would not want to extract kernel-specific
        //  constructs like magics)
        return new VirtualDocument({
            language: this.language,
            file_extension: this.language_file_extension,
            path: this.document_path,
            overrides_registry: {},
            foreign_code_extractors: {},
            standalone: true,
            has_lsp_supported_file: true
        });
    }
}
//# sourceMappingURL=file_editor.js.map