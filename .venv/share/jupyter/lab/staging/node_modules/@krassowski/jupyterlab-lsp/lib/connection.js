import { LspWsConnection } from 'lsp-ws-connection';
import { until_ready } from './utils';
export class LSPConnection extends LspWsConnection {
    constructor(options) {
        super(options);
        this.closing_manually = false;
        this.documentsToOpen = [];
    }
    sendOpenWhenReady(documentInfo) {
        if (this.isReady) {
            this.sendOpen(documentInfo);
        }
        else {
            this.documentsToOpen.push(documentInfo);
        }
    }
    onServerInitialized(params) {
        super.onServerInitialized(params);
        while (this.documentsToOpen.length) {
            this.sendOpen(this.documentsToOpen.pop());
        }
    }
    sendSelectiveChange(changeEvent, documentInfo) {
        this._sendChange([changeEvent], documentInfo);
    }
    sendFullTextChange(text, documentInfo) {
        this._sendChange([{ text }], documentInfo);
    }
    isRenameSupported() {
        return !!(this.serverCapabilities && this.serverCapabilities.renameProvider);
    }
    async rename(location, documentInfo, newName, emit = true) {
        if (!this.isReady || !this.isRenameSupported()) {
            return;
        }
        const params = {
            textDocument: {
                uri: documentInfo.uri
            },
            position: {
                line: location.line,
                character: location.ch
            },
            newName
        };
        const edit = await this.connection.sendRequest('textDocument/rename', params);
        if (emit) {
            this.emit('renamed', edit);
        }
        return edit;
    }
    connect(socket) {
        super.connect(socket);
        until_ready(() => {
            return this.isConnected;
        }, -1)
            .then(() => {
            this.connection.onClose(() => {
                this.isConnected = false;
                this.emit('close', this.closing_manually);
            });
        })
            .catch(() => {
            console.error('Could not connect onClose signal');
        });
        return this;
    }
    close() {
        try {
            this.closing_manually = true;
            super.close();
        }
        catch (e) {
            this.closing_manually = false;
        }
    }
    _sendChange(changeEvents, documentInfo) {
        if (!this.isReady) {
            return;
        }
        if (!this.openedUris.get(documentInfo.uri)) {
            this.sendOpen(documentInfo);
        }
        const textDocumentChange = {
            textDocument: {
                uri: documentInfo.uri,
                version: documentInfo.version
            },
            contentChanges: changeEvents
        };
        this.connection.sendNotification('textDocument/didChange', textDocumentChange);
        documentInfo.version++;
    }
}
//# sourceMappingURL=connection.js.map