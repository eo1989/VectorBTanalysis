import React from 'react';
import { VDomModel, VDomRenderer } from '@jupyterlab/apputils';
import { caretDownIcon, caretUpIcon } from '@jupyterlab/ui-components';
import '../../../style/diagnostics_listing.css';
import { DiagnosticSeverity } from '../../lsp';
import { DocumentLocator, focus_on } from '../../components/utils';
export const DIAGNOSTICS_LISTING_CLASS = 'lsp-diagnostics-listing';
export class DiagnosticsDatabase extends Map {
    get all() {
        return [].concat.apply([], this.values());
    }
}
class Column {
    constructor(options) {
        this.options = options;
        this.is_visible = true;
    }
    render_cell(data, context) {
        return this.options.render_cell(data, context);
    }
    sort(a, b) {
        return this.options.sort(a, b);
    }
    get name() {
        return this.options.name;
    }
    is_available(context) {
        if (this.options.is_available != null) {
            return this.options.is_available(context);
        }
        return true;
    }
    render_header(listing) {
        return React.createElement(SortableTH, { name: this.name, listing: listing, key: this.name });
    }
}
function SortableTH(props) {
    const is_sort_key = props.name === props.listing.sort_key;
    const sortIcon = !is_sort_key || props.listing.sort_direction === 1
        ? caretUpIcon
        : caretDownIcon;
    return (React.createElement("th", { key: props.name, onClick: () => props.listing.sort(props.name), className: is_sort_key ? 'lsp-sorted-header' : null },
        React.createElement("div", null,
            React.createElement("label", null, props.name),
            React.createElement(sortIcon.react, { tag: "span", className: "lsp-sort-icon" }))));
}
export function message_without_code(diagnostic) {
    let message = diagnostic.message;
    let code_str = '' + diagnostic.code;
    if (diagnostic.code != null &&
        diagnostic.code !== '' &&
        message.startsWith(code_str + '')) {
        return message.slice(code_str.length).trim();
    }
    return message;
}
export class DiagnosticsListing extends VDomRenderer {
    constructor() {
        super(...arguments);
        this.sort_key = 'Severity';
        this.sort_direction = 1;
        this.columns = [
            new Column({
                name: 'Virtual Document',
                render_cell: (row, context) => (React.createElement("td", { key: 0 },
                    React.createElement(DocumentLocator, { document: row.document, adapter: context.adapter }))),
                sort: (a, b) => a.document.id_path.localeCompare(b.document.id_path),
                is_available: context => context.db.size > 1
            }),
            new Column({
                name: 'Message',
                render_cell: row => {
                    let message = message_without_code(row.data.diagnostic);
                    return React.createElement("td", { key: 1 }, message);
                },
                sort: (a, b) => a.data.diagnostic.message.localeCompare(b.data.diagnostic.message)
            }),
            new Column({
                name: 'Code',
                render_cell: row => React.createElement("td", { key: 2 }, row.data.diagnostic.code),
                sort: (a, b) => (a.data.diagnostic.code + '').localeCompare(b.data.diagnostic.source + '')
            }),
            new Column({
                name: 'Severity',
                // TODO: use default diagnostic severity
                render_cell: row => (React.createElement("td", { key: 3 }, DiagnosticSeverity[row.data.diagnostic.severity || 1])),
                sort: (a, b) => a.data.diagnostic.severity > b.data.diagnostic.severity ? 1 : -1
            }),
            new Column({
                name: 'Source',
                render_cell: row => React.createElement("td", { key: 4 }, row.data.diagnostic.source),
                sort: (a, b) => a.data.diagnostic.source.localeCompare(b.data.diagnostic.source)
            }),
            new Column({
                name: 'Cell',
                render_cell: row => React.createElement("td", { key: 5 }, row.cell_number),
                sort: (a, b) => a.cell_number > b.cell_number
                    ? 1
                    : a.data.range.start.line > b.data.range.start.line
                        ? 1
                        : a.data.range.start.ch > b.data.range.start.ch
                            ? 1
                            : -1,
                is_available: context => context.adapter.has_multiple_editors
            }),
            new Column({
                name: 'Line:Ch',
                render_cell: row => (React.createElement("td", { key: 6 },
                    row.data.range.start.line,
                    ":",
                    row.data.range.start.ch)),
                sort: (a, b) => a.data.range.start.line > b.data.range.start.line
                    ? 1
                    : a.data.range.start.ch > b.data.range.start.ch
                        ? 1
                        : -1
            })
        ];
    }
    sort(key) {
        if (key === this.sort_key) {
            this.sort_direction = this.sort_direction * -1;
        }
        else {
            this.sort_key = key;
            this.sort_direction = 1;
        }
        this.update();
    }
    render() {
        let diagnostics_db = this.model.diagnostics;
        const editor = this.model.virtual_editor;
        const adapter = this.model.adapter;
        if (!diagnostics_db || editor == null) {
            return React.createElement("div", null, "No issues detected, great job!");
        }
        let by_document = Array.from(diagnostics_db).map(([virtual_document, diagnostics]) => {
            if (virtual_document.isDisposed) {
                return [];
            }
            return diagnostics.map((diagnostic_data, i) => {
                let cell_number = null;
                if (adapter.has_multiple_editors) {
                    let { index: cell_id } = editor.find_editor(diagnostic_data.editor);
                    cell_number = cell_id + 1;
                }
                return {
                    data: diagnostic_data,
                    key: virtual_document.uri + ',' + i,
                    document: virtual_document,
                    cell_number: cell_number,
                    editor: editor
                };
            });
        });
        let flattened = [].concat.apply([], by_document);
        this._diagnostics = new Map(flattened.map(row => [row.key, row]));
        let sorted_column = this.columns.filter(column => column.name === this.sort_key)[0];
        let sorter = sorted_column.sort.bind(sorted_column);
        let sorted = flattened.sort((a, b) => sorter(a, b) * this.sort_direction);
        let context = {
            db: diagnostics_db,
            editor: editor,
            adapter: adapter
        };
        let columns_to_display = this.columns.filter(column => column.is_available(context) && column.is_visible);
        let elements = sorted.map(row => {
            let cells = columns_to_display.map(column => column.render_cell(row, context));
            return (React.createElement("tr", { key: row.key, "data-key": row.key, onClick: () => {
                    this.jump_to(row);
                } }, cells));
        });
        let columns_headers = columns_to_display.map(column => column.render_header(this));
        return (React.createElement("table", { className: DIAGNOSTICS_LISTING_CLASS },
            React.createElement("thead", null,
                React.createElement("tr", null, columns_headers)),
            React.createElement("tbody", null, elements)));
    }
    get_diagnostic(key) {
        if (!this._diagnostics.has(key)) {
            console.warn('Could not find the diagnostics row with key', key);
            return;
        }
        return this._diagnostics.get(key);
    }
    jump_to(row) {
        const cm_editor = row.data.editor;
        focus_on(cm_editor.getWrapperElement());
        cm_editor.getDoc().setCursor(row.data.range.start);
        cm_editor.focus();
    }
}
(function (DiagnosticsListing) {
    /**
     * A VDomModel for the LSP of current file editor/notebook.
     */
    class Model extends VDomModel {
        constructor() {
            super();
        }
    }
    DiagnosticsListing.Model = Model;
})(DiagnosticsListing || (DiagnosticsListing = {}));
//# sourceMappingURL=listing.js.map