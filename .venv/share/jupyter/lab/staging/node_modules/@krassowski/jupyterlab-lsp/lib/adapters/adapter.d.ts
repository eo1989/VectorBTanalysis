import { JupyterFrontEnd } from '@jupyterlab/application';
import { CodeEditor } from '@jupyterlab/codeeditor';
import { DocumentRegistry, IDocumentWidget } from '@jupyterlab/docregistry';
import { IVirtualEditor } from '../virtual/editor';
import { IForeignContext, VirtualDocument } from '../virtual/document';
import { Signal } from '@lumino/signaling';
import { IRootPosition, IVirtualPosition } from '../positioning';
import { LSPConnection } from '../connection';
import { ICommandContext } from '../command_manager';
import { DocumentConnectionManager, IDocumentConnectionData } from '../connection_manager';
import { ILSPExtension } from '../index';
import { IFeatureEditorIntegration, IFeature } from '../feature';
import { EditorAdapter } from '../editor_integration/editor_adapter';
import IEditor = CodeEditor.IEditor;
import { LanguageIdentifier } from '../lsp';
export declare class StatusMessage {
    /**
     * The text message to be shown on the statusbar
     */
    message: string;
    changed: Signal<StatusMessage, void>;
    private timer;
    constructor();
    /**
     * Set the text message and (optionally) the timeout to remove it.
     * @param message
     * @param timeout - number of ms to until the message is cleaned;
     *        -1 if the message should stay up indefinitely;
     *        defaults to 3000ms (3 seconds)
     */
    set(message: string, timeout?: number): void;
    clear(): void;
    private expire_timer;
}
export interface IEditorChangedData {
    editor: CodeEditor.IEditor;
}
/**
 * Foreign code: low level adapter is not aware of the presence of foreign languages;
 * it operates on the virtual document and must not attempt to infer the language dependencies
 * as this would make the logic of inspections caching impossible to maintain, thus the WidgetAdapter
 * has to handle that, keeping multiple connections and multiple virtual documents.
 */
export declare abstract class WidgetAdapter<T extends IDocumentWidget> {
    protected extension: ILSPExtension;
    widget: T;
    protected adapters: Map<VirtualDocument.id_path, EditorAdapter<IVirtualEditor<IEditor>>>;
    adapterConnected: Signal<WidgetAdapter<T>, IDocumentConnectionData>;
    isConnected: boolean;
    connection_manager: DocumentConnectionManager;
    status_message: StatusMessage;
    protected isDisposed: boolean;
    protected app: JupyterFrontEnd;
    activeEditorChanged: Signal<WidgetAdapter<T>, IEditorChangedData>;
    update_finished: Promise<void>;
    /**
     * (re)create virtual document using current path and language
     */
    abstract create_virtual_document(): VirtualDocument;
    abstract get_editor_index_at(position: IVirtualPosition): number;
    abstract get_editor_index(ce_editor: CodeEditor.IEditor): number;
    abstract get_editor_wrapper(ce_editor: CodeEditor.IEditor): HTMLElement;
    protected constructor(extension: ILSPExtension, widget: T);
    protected get foreign_code_extractors(): import("../extractors/types").IForeignCodeExtractorsRegistry;
    protected get code_overrides(): import("../overrides/tokens").ICodeOverridesRegistry;
    on_connection_closed(manager: DocumentConnectionManager, { virtual_document }: IDocumentConnectionData): void;
    dispose(): void;
    virtual_editor: IVirtualEditor<IEditor>;
    abstract get document_path(): string;
    abstract get mime_type(): string;
    get widget_id(): string;
    get language(): LanguageIdentifier;
    abstract get language_file_extension(): string;
    protected reload_connection(): void;
    protected on_save_state(context: any, state: DocumentRegistry.SaveState): void;
    abstract activeEditor: CodeEditor.IEditor;
    abstract get editors(): CodeEditor.IEditor[];
    /**
     * public for use in tests (but otherwise could be private)
     */
    update_documents(): Promise<void>;
    get has_multiple_editors(): boolean;
    protected on_connected(data: IDocumentConnectionData): Promise<void>;
    /**
     * Opens a connection for the document. The connection may or may
     * not be initialized, yet, and depending on when this is called, the client
     * may not be fully connected.
     *
     * @param virtual_document a VirtualDocument
     * @param send_open whether to open the document immediately
     */
    protected connect_document(virtual_document: VirtualDocument, send_open?: boolean): Promise<void>;
    private create_virtual_editor;
    protected init_virtual(): void;
    /**
     * Handler for opening a document contained in a parent document. The assumption
     * is that the editor already exists for this, and as such the document
     * should be queued for immediate opening.
     *
     * @param host the VirtualDocument that contains the VirtualDocument in another language
     * @param context information about the foreign VirtualDocument
     */
    protected on_foreign_document_opened(host: VirtualDocument, context: IForeignContext): Promise<void>;
    private on_foreign_document_closed;
    document_changed(virtual_document: VirtualDocument, document: VirtualDocument, is_init?: boolean): void;
    connect_adapter(virtual_document: VirtualDocument, connection: LSPConnection, features?: IFeature[]): EditorAdapter<any>;
    private disconnect_adapter;
    get_features(virtual_document: VirtualDocument): Map<string, IFeatureEditorIntegration<IVirtualEditor<CodeEditor.IEditor>>>;
    private connect;
    /**
     * Connect the change signal in order to update all virtual documents after a change.
     *
     * Update to the state of a notebook may be done without a notice on the CodeMirror level,
     * e.g. when a cell is deleted. Therefore a JupyterLab-specific signals are watched instead.
     *
     * While by not using the change event of CodeMirror editors we loose an easy way to send selective,
     * (range) updates this can be still implemented by comparison of before/after states of the
     * virtual documents, which is even more resilient and -obviously - editor-independent.
     */
    connect_contentChanged_signal(): void;
    private create_adapter;
    private onContentChanged;
    get_position_from_context_menu(): IRootPosition;
    abstract context_from_active_document(): ICommandContext | null;
    get_context(root_position: IRootPosition): ICommandContext;
    get_context_from_context_menu(): ICommandContext;
    abstract get wrapper_element(): HTMLElement;
}
