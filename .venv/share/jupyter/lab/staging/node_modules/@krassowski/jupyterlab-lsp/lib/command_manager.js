function is_context_menu_over_token(adapter) {
    let position = adapter.get_position_from_context_menu();
    if (!position) {
        return false;
    }
    let token = adapter.virtual_editor.get_token_at(position);
    return token.value !== '';
}
class LSPCommandManager {
    constructor(options) {
        this.add_to_palette = true;
        this.category = 'Language Server Protocol';
        this.adapter_manager = options.adapter_manager;
        this.app = options.app;
        this.palette = options.palette;
        this.tracker = options.tracker;
        this.suffix = options.suffix;
        this.entry_point = options.entry_point;
    }
    get current_adapter() {
        return this.adapter_manager.currentAdapter;
    }
    add(commands) {
        for (let cmd of commands) {
            let id = this.create_id(cmd);
            this.app.commands.addCommand(id, {
                execute: () => this.execute(cmd),
                isEnabled: () => this.is_enabled(cmd),
                isVisible: () => this.is_visible(cmd),
                label: cmd.label,
                icon: cmd.icon
            });
            if (this.should_attach(cmd)) {
                this.attach_command(cmd);
            }
            if (this.add_to_palette) {
                this.palette.addItem({ command: id, category: this.category });
            }
        }
    }
    should_attach(command) {
        if (command.attach_to == null) {
            return true;
        }
        return command.attach_to.has(this.entry_point);
    }
    create_id(command) {
        return 'lsp:' + command.id + '-' + this.suffix;
    }
}
/**
 * Contextual commands, with the context retrieved from the ContextMenu
 * position (if open) or from the cursor in the current widget.
 */
export class ContextCommandManager extends LSPCommandManager {
    constructor(options) {
        super(options);
        this.selector = options.selector;
        this.entry_point = options.entry_point;
        this.rank_group = options.rank_group;
        this.rank_group_size = options.rank_group_size;
        if (options.callback) {
            options.callback(this);
        }
    }
    attach_command(command) {
        this.app.contextMenu.addItem({
            selector: this.selector,
            command: this.create_id(command),
            rank: this.get_rank(command)
        });
    }
    add_context_separator(position_in_group) {
        this.app.contextMenu.addItem({
            type: 'separator',
            selector: this.selector,
            rank: this.rank_group + position_in_group
        });
    }
    execute(command) {
        let context = this.get_context();
        if (context) {
            command.execute(context);
        }
    }
    get is_context_menu_open() {
        return this.app.contextMenu.menu.isAttached;
    }
    get is_widget_current() {
        // is the current widget of given type (notebook/editor)
        // also the currently used widget in the entire app?
        return (this.tracker.currentWidget != null &&
            this.tracker.currentWidget === this.app.shell.currentWidget);
    }
    is_enabled() {
        if (this.is_context_menu_open) {
            return is_context_menu_over_token(this.current_adapter);
        }
        else {
            return this.is_widget_current;
        }
    }
    get_context() {
        var _a;
        let context = null;
        if (this.is_context_menu_open) {
            try {
                context = this.current_adapter.get_context_from_context_menu();
            }
            catch (e) {
                console.warn('contextMenu is attached, but could not get the context', e);
                context = null;
            }
        }
        if (context == null) {
            context = (_a = this.current_adapter) === null || _a === void 0 ? void 0 : _a.context_from_active_document();
        }
        return context;
    }
    is_visible(command) {
        var _a;
        try {
            let context = this.get_context();
            return (context != null &&
                this.current_adapter && ((_a = context.connection) === null || _a === void 0 ? void 0 : _a.isReady) &&
                command.is_enabled(context));
        }
        catch (e) {
            console.warn('is_visible failed', e);
            return false;
        }
    }
    get_rank(command) {
        let is_relative = typeof command.is_rank_relative === 'undefined'
            ? true
            : command.is_rank_relative;
        if (is_relative &&
            typeof this.rank_group !== 'undefined' &&
            this.rank_group_size) {
            let relative = typeof command.rank !== 'undefined' ? command.rank : 0;
            return this.rank_group + relative / this.rank_group_size;
        }
        else {
            return command.rank != null ? command.rank : Infinity;
        }
    }
}
//# sourceMappingURL=command_manager.js.map