import * as CodeMirror from 'codemirror';
import { CodeMirrorEditor } from '@jupyterlab/codemirror';
import { CodeEditor } from '@jupyterlab/codeeditor';
import { IEditorName } from '../feature';
import { VirtualDocument } from './document';
import { IForeignCodeExtractorsRegistry } from '../extractors/types';
import { EditorLogConsole } from './console';
import { Signal } from '@lumino/signaling';
import { IEditorPosition, IRootPosition, IVirtualPosition } from '../positioning';
import { IEditorChange, IVirtualEditor, IWindowCoordinates } from './editor';
import { WidgetAdapter } from '../adapters/adapter';
import { IDocumentWidget } from '@jupyterlab/docregistry';
import { JupyterFrontEndPlugin } from '@jupyterlab/application';
export declare type CodeMirrorHandler = (instance: any, ...args: any[]) => void;
/**
 * VirtualEditor extends the CodeMirror.Editor interface; its subclasses may either
 * fast-forward any requests to an existing instance of the CodeMirror.Editor
 * (using ES6 Proxy), or implement custom behaviour, allowing for the use of
 * virtual documents representing code in complex entities such as notebooks.
 */
export declare class CodeMirrorVirtualEditor implements IVirtualEditor<CodeMirrorEditor>, CodeMirror.Editor {
    editor_name: IEditorName;
    virtual_document: VirtualDocument;
    code_extractors: IForeignCodeExtractorsRegistry;
    console: EditorLogConsole;
    cm_editor_to_ce_editor: Map<CodeMirror.Editor, CodeEditor.IEditor>;
    ce_editor_to_cm_editor: Map<CodeEditor.IEditor, CodeMirror.Editor>;
    isDisposed: boolean;
    change: Signal<IVirtualEditor<CodeMirrorEditor>, IEditorChange>;
    editor_to_source_line: Map<CodeEditor.IEditor, number>;
    private editor_to_source_line_new;
    private _proxy;
    protected readonly adapter: WidgetAdapter<IDocumentWidget>;
    constructor(options: IVirtualEditor.IOptions);
    dispose(): void;
    get_cursor_position(): IRootPosition;
    private onEditorsUpdated;
    private save_block_position;
    private set_event_handlers;
    private emit_change;
    window_coords_to_root_position(coordinates: IWindowCoordinates): IRootPosition;
    get_token_at(position: IRootPosition): CodeEditor.IToken;
    get_cm_editor(position: IRootPosition): CodeMirror.Editor;
    transform_virtual_to_editor(position: IVirtualPosition): IEditorPosition;
    document_at_root_position(position: IRootPosition): VirtualDocument;
    root_position_to_virtual_position(position: IRootPosition): IVirtualPosition;
    get_editor_at_root_position(root_position: IRootPosition): CodeEditor.IEditor;
    root_position_to_editor(root_position: IRootPosition): IEditorPosition;
    private _event_wrappers;
    /**
     * Proxy the event handler binding to the CodeMirror editors,
     * allowing for multiple actual editors per a virtual editor.
     *
     * Only handlers accepting CodeMirror.Editor are supported for simplicity.
     */
    on(eventName: string, handler: CodeMirrorHandler, ...args: any[]): void;
    off(eventName: string, handler: CodeMirrorHandler, ...args: any[]): void;
    find_ce_editor(cm_editor: CodeMirror.Editor): CodeEditor.IEditor;
    transform_from_editor_to_root(editor: CodeEditor.IEditor, position: IEditorPosition): IRootPosition | null;
    transform_from_root_to_editor(pos: IRootPosition): CodeMirror.Position;
    state: any;
    addKeyMap(map: string | CodeMirror.KeyMap, bottom?: boolean): void;
    addLineClass(line: any, where: string, _class: string): CodeMirror.LineHandle;
    addLineWidget(line: any, node: HTMLElement, options?: CodeMirror.LineWidgetOptions): CodeMirror.LineWidget;
    addOverlay(mode: any, options?: any): void;
    addPanel(node: HTMLElement, options?: CodeMirror.ShowPanelOptions): CodeMirror.Panel;
    charCoords(pos: IRootPosition, mode?: 'window' | 'page' | 'local'): {
        left: number;
        right: number;
        top: number;
        bottom: number;
    };
    coordsChar(object: {
        left: number;
        top: number;
    }, mode?: 'window' | 'page' | 'local'): IRootPosition;
    cursorCoords(where?: boolean, mode?: 'window' | 'page' | 'local'): {
        left: number;
        top: number;
        bottom: number;
    };
    cursorCoords(where?: IRootPosition | null, mode?: 'window' | 'page' | 'local'): {
        left: number;
        top: number;
        bottom: number;
    };
    get any_editor(): CodeMirror.Editor;
    defaultCharWidth(): number;
    defaultTextHeight(): number;
    endOperation(): void;
    execCommand(name: string): void;
    getDoc(): CodeMirror.Doc;
    private get_editor_at_root_line;
    getTokenAt(pos: IRootPosition, precise?: boolean): CodeMirror.Token;
    getTokenTypeAt(pos: IRootPosition): string;
    get_editor_value(editor: CodeEditor.IEditor): string;
    getWrapperElement(): HTMLElement;
    heightAtLine(line: any, mode?: 'window' | 'page' | 'local', includeWidgets?: boolean): number;
    isReadOnly(): boolean;
    lineAtHeight(height: number, mode?: 'window' | 'page' | 'local'): number;
    addEventListener(type: string, listener: EventListenerOrEventListenerObject): void;
    forEveryBlockEditor(callback: (cm_editor: CodeMirror.Editor) => any, monitor_for_new_blocks?: boolean): void;
    /**
     * Find a cell in notebook which uses given CodeMirror editor.
     * This function is O(n) - when looking up many cells
     * using a hashmap based approach may be more efficient.
     * @param cm_editor
     */
    find_editor(cm_editor: CodeMirror.Editor): {
        index: number;
        node: HTMLElement;
    };
}
export interface CodeMirrorVirtualEditor extends CodeMirror.Editor {
}
export declare const CODEMIRROR_VIRTUAL_EDITOR: JupyterFrontEndPlugin<void>;
