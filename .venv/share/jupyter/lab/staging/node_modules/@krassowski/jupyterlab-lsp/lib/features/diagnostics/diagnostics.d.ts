import * as lsProtocol from 'vscode-languageserver-protocol';
import { MainAreaWidget } from '@jupyterlab/apputils';
import { DiagnosticsDatabase, DiagnosticsListing } from './listing';
import { FeatureSettings } from '../../feature';
import { CodeMirrorIntegration } from '../../editor_integration/codemirror';
import { CodeDiagnostics as LSPDiagnosticsSettings } from '../../_diagnostics';
import { CodeMirrorVirtualEditor } from '../../virtual/codemirror_editor';
import { LabIcon } from '@jupyterlab/ui-components';
import { JupyterFrontEnd } from '@jupyterlab/application';
export declare const diagnosticsIcon: LabIcon;
declare class DiagnosticsPanel {
    private _content;
    private _widget;
    feature: DiagnosticsCM;
    is_registered: boolean;
    get widget(): MainAreaWidget<DiagnosticsListing>;
    get content(): DiagnosticsListing;
    protected init_widget(): MainAreaWidget<DiagnosticsListing>;
    update(): void;
    register(app: JupyterFrontEnd): void;
}
export declare const diagnostics_panel: DiagnosticsPanel;
export declare const diagnostics_databases: WeakMap<CodeMirrorVirtualEditor, DiagnosticsDatabase>;
export declare class DiagnosticsCM extends CodeMirrorIntegration {
    settings: FeatureSettings<LSPDiagnosticsSettings>;
    private last_response;
    register(): void;
    private unique_editor_ids;
    private marked_diagnostics;
    /**
     * Allows access to the most recent diagnostics in context of the editor.
     *
     * One can use VirtualEditorForNotebook.find_cell_by_editor() to find
     * the corresponding cell in notebook.
     * Can be used to implement a Panel showing diagnostics list.
     *
     * Maps virtual_document.uri to IEditorDiagnostic[].
     */
    diagnostics_db: DiagnosticsDatabase;
    switchDiagnosticsPanelSource: () => void;
    protected collapse_overlapping_diagnostics(diagnostics: lsProtocol.Diagnostic[]): Map<lsProtocol.Range, lsProtocol.Diagnostic[]>;
    get defaultSeverity(): lsProtocol.DiagnosticSeverity;
    private filterDiagnostics;
    setDiagnostics(response: lsProtocol.PublishDiagnosticsParams): void;
    handleDiagnostic: (response: lsProtocol.PublishDiagnosticsParams) => void;
    refreshDiagnostics(): void;
    protected remove_unused_diagnostic_markers(to_retain: Set<string>): void;
    remove(): void;
}
export {};
