import * as lsProtocol from 'vscode-languageserver-protocol';
import { IRootPosition } from '../positioning';
import { CodeMirrorIntegration } from '../editor_integration/codemirror';
import { FeatureSettings, IFeatureLabIntegration } from '../feature';
import { JupyterFrontEnd, JupyterFrontEndPlugin } from '@jupyterlab/application';
import { ILSPAdapterManager } from '../tokens';
import { IRenderMimeRegistry } from '@jupyterlab/rendermime';
import { EditorTooltipManager } from '../components/free_tooltip';
import { IEditorChange } from '../virtual/editor';
export declare class SignatureCM extends CodeMirrorIntegration {
    protected signature_character: IRootPosition;
    protected _signatureCharacters: string[];
    lab_integration: SignatureLabIntegration;
    protected get_markup_for_signature_help(response: lsProtocol.SignatureHelp, language: string): lsProtocol.MarkupContent;
    /**
     * A temporary workaround for the LSP servers returning plain text (e.g. docstrings)
     * (providing not-the-best UX) instead of markdown and me being unable to force
     * them to return markdown instead.
     */
    private markdown_from_signature;
    private handleSignature;
    get signatureCharacters(): string[];
    afterChange(change: IEditorChange, root_position: IRootPosition): void;
}
declare class SignatureLabIntegration implements IFeatureLabIntegration {
    tooltip: EditorTooltipManager;
    settings: FeatureSettings<any>;
    constructor(app: JupyterFrontEnd, settings: FeatureSettings<any>, renderMimeRegistry: IRenderMimeRegistry, adapterManager: ILSPAdapterManager);
}
export declare const SIGNATURE_PLUGIN: JupyterFrontEndPlugin<void>;
export {};
