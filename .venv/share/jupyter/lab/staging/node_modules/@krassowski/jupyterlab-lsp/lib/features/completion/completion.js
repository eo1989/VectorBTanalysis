import { AdditionalCompletionTriggerKinds, CompletionTriggerKind } from '../../lsp';
import { CodeMirrorIntegration } from '../../editor_integration/codemirror';
import { LSPConnector } from './completion_handler';
import { NotebookAdapter } from '../../adapters/notebook/notebook';
export class CompletionCM extends CodeMirrorIntegration {
    get completionCharacters() {
        if (this._completionCharacters == null ||
            !this._completionCharacters.length) {
            this._completionCharacters = this.connection.getLanguageCompletionCharacters();
        }
        return this._completionCharacters;
    }
    // public handleCompletion(completions: lsProtocol.CompletionItem[]) {
    // TODO: populate the (already displayed) completions list if the completions timed out initially?
    // }
    afterChange(change) {
        // TODO: maybe the completer could be kicked off in the handleChange() method directly; signature help still
        //  requires an up-to-date virtual document on the LSP side, so we need to wait for sync.
        if (change.text &&
            change.text[0].length == 1 &&
            this.settings.composite.continuousHinting) {
            this.feature.labIntegration
                .invoke_completer(AdditionalCompletionTriggerKinds.AutoInvoked)
                .catch(console.warn);
            return;
        }
        let last_character = this.extract_last_character(change);
        if (this.completionCharacters.indexOf(last_character) > -1) {
            this.virtual_editor.console.log('Will invoke completer after', last_character);
            this.feature.labIntegration
                .invoke_completer(CompletionTriggerKind.TriggerCharacter)
                .catch(console.warn);
        }
    }
}
export class CompletionLabIntegration {
    constructor(app, completionManager, settings, adapterManager, completionThemeManager) {
        this.app = app;
        this.completionManager = completionManager;
        this.settings = settings;
        this.adapterManager = adapterManager;
        this.completionThemeManager = completionThemeManager;
        this.current_adapter = null;
        adapterManager.adapterChanged.connect(this.swap_adapter, this);
        settings.changed.connect(() => {
            completionThemeManager.set_theme(this.settings.composite.theme);
        });
    }
    swap_adapter(manager, adapter) {
        if (this.current_adapter) {
            // disconnect signals from the old adapter
            this.current_adapter.activeEditorChanged.disconnect(this.set_connector, this);
            this.current_adapter.adapterConnected.disconnect(this.connect_completion, this);
        }
        this.current_adapter = adapter;
        // connect the new adapter
        if (this.current_adapter.isConnected) {
            this.connect_completion(this.current_adapter);
            this.set_connector(adapter, { editor: adapter.activeEditor });
        }
        // connect signals to the new adapter
        this.current_adapter.activeEditorChanged.connect(this.set_connector, this);
        this.current_adapter.adapterConnected.connect(this.connect_completion, this);
    }
    connect_completion(adapter, data) {
        let editor = adapter.activeEditor;
        if (editor == null) {
            return;
        }
        this.set_completion_connector(adapter, editor);
        this.current_completion_handler = this.completionManager.register({
            connector: this.current_completion_connector,
            editor: editor,
            parent: adapter.widget
        });
    }
    invoke_completer(kind) {
        let command;
        this.current_completion_connector.trigger_kind = kind;
        if (this.adapterManager.currentAdapter instanceof NotebookAdapter) {
            command = 'completer:invoke-notebook';
        }
        else {
            command = 'completer:invoke-file';
        }
        return this.app.commands.execute(command).catch(() => {
            this.current_completion_connector.trigger_kind =
                CompletionTriggerKind.Invoked;
        });
    }
    set_connector(adapter, editor_changed) {
        if (!this.current_completion_handler) {
            // workaround for current_completion_handler not being there yet
            this.connect_completion(adapter);
        }
        this.set_completion_connector(adapter, editor_changed.editor);
        this.current_completion_handler.editor = editor_changed.editor;
        this.current_completion_handler.connector = this.current_completion_connector;
    }
    set_completion_connector(adapter, editor) {
        var _a, _b;
        if (this.current_completion_connector) {
            delete this.current_completion_connector;
        }
        this.current_completion_connector = new LSPConnector({
            editor: editor,
            themeManager: this.completionThemeManager,
            connections: this.current_adapter.connection_manager.connections,
            virtual_editor: this.current_adapter.virtual_editor,
            settings: this.settings,
            // it might or might not be a notebook panel (if it is not, the sessionContext and session will just be undefined)
            session: (_b = (_a = this.current_adapter.widget) === null || _a === void 0 ? void 0 : _a.sessionContext) === null || _b === void 0 ? void 0 : _b.session
        });
    }
}
//# sourceMappingURL=completion.js.map